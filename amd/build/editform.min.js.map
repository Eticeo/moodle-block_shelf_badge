{"version":3,"file":"editform.min.js","sources":["../src/editform.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Javascript to initialise the shelf badge edit_form block.\n *\n * @module block_shelf_badge/editform\n * @copyright   2023 eticeo <contact@eticeo.fr>\n * @copyright   2023 Jeremy Carre <jeremy.carre@eticeo.fr>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n// Import jquery from moodle src.\nimport $ from 'jquery';\n\n// Import our third-party libs.\nimport 'block_shelf_badge/select2';\n\n/**\n * Function call in php.\n * @param instid\n * @param waitModal bool : true if we need to wait modal to call js. False if not (ex: load param is tab)\n */\nexport const init = (instid, waitModal) => {\n    if (waitModal) {\n        // Call specific function.\n        block_shelf_badge_waitmodal(instid);\n    } else {\n        // Go on.\n        block_shelf_badge_on_open();\n    }\n};\n\nfunction block_shelf_badge_on_open() {\n    $('[name=\"config_user_role[]\"]').select2({placeholder: M.util.get_string('select_user_role', 'block_shelf_badge')});\n}\n\n/**\n * Function wait specifique element are NOT here to continue.\n * @param selector string: the specifique element selector\n * @returns {Promise}\n */\nfunction block_shelf_badge_waitForNotElm(selector) {\n    return new Promise(resolve => {\n        if (!document.querySelector(selector)) {\n            return resolve(document.querySelector(selector));\n        }\n\n        const observer = new MutationObserver(mutations => {\n            if (!document.querySelector(selector)) {\n                resolve(document.querySelector(selector));\n                observer.disconnect();\n            }\n        });\n\n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n    });\n}\n\n/**\n * Function wait specifique element are here to continue.\n * @param selector string: the specifique element selector\n * @returns {Promise}\n */\nfunction block_shelf_badge_waitForElm(selector) {\n    return new Promise(resolve => {\n        if (document.querySelector(selector)) {\n            return resolve(document.querySelector(selector));\n        }\n\n        const observer = new MutationObserver(mutations => {\n            if (document.querySelector(selector)) {\n                resolve(document.querySelector(selector));\n                observer.disconnect();\n            }\n        });\n\n        observer.observe(document.body, {\n            childList: true,\n            subtree: true\n        });\n    });\n}\n\nfunction block_shelf_badge_waitmodal(instid) {\n    // We need to wait specifique element (which is in modal) to run init.\n    block_shelf_badge_waitForElm(\"input[name='blockid'][value='\" + instid + \"']\").then((elm) => {\n        // Element is her, run init.\n        block_shelf_badge_on_open();\n\n        // And now wait modal closed to rerun the waitmodal.\n        block_shelf_badge_waitdestroymodal(instid);\n    });\n}\n\n/**\n * Needed in case we open, close then reopen modal.\n */\nfunction block_shelf_badge_waitdestroymodal(instid) {\n    block_shelf_badge_waitForNotElm(\"input[name='blockid'][value='\" + instid + \"']\").then((elm) => {\n        block_shelf_badge_on_open();\n        block_shelf_badge_waitmodal(instid);\n    });\n}\n"],"names":["block_shelf_badge_on_open","select2","placeholder","M","util","get_string","block_shelf_badge_waitmodal","instid","selector","Promise","resolve","document","querySelector","observer","MutationObserver","mutations","disconnect","observe","body","childList","subtree","then","elm","block_shelf_badge_waitForNotElm","block_shelf_badge_waitdestroymodal","waitModal"],"mappings":";;;;;;;;mJA6CSA,gDACH,+BAA+BC,QAAQ,CAACC,YAAaC,EAAEC,KAAKC,WAAW,mBAAoB,gCAqDxFC,4BAA4BC,YApBCC,UAAAA,SAsBL,gCAAkCD,OAAS,KArBjE,IAAIE,SAAQC,aACXC,SAASC,cAAcJ,iBAChBE,QAAQC,SAASC,cAAcJ,iBAGpCK,SAAW,IAAIC,kBAAiBC,YAC9BJ,SAASC,cAAcJ,YACvBE,QAAQC,SAASC,cAAcJ,WAC/BK,SAASG,iBAIjBH,SAASI,QAAQN,SAASO,KAAM,CAC5BC,WAAW,EACXC,SAAS,QAO6DC,MAAMC,MAEhFtB,qCAUoCO,kBA3DHC,iBAC9B,IAAIC,SAAQC,cACVC,SAASC,cAAcJ,iBACjBE,QAAQC,SAASC,cAAcJ,iBAGpCK,SAAW,IAAIC,kBAAiBC,YAC7BJ,SAASC,cAAcJ,YACxBE,QAAQC,SAASC,cAAcJ,WAC/BK,SAASG,iBAIjBH,SAASI,QAAQN,SAASO,KAAM,CAC5BC,WAAW,EACXC,SAAS,QA6CjBG,CAAgC,gCAAkChB,OAAS,MAAMc,MAAMC,MACnFtB,4BACAM,4BAA4BC,WAV5BiB,CAAmCjB,yBAvEvB,CAACA,OAAQkB,aACrBA,UAEAnB,4BAA4BC,QAG5BP"}